#!/usr/bin/env bash
#
#: Title        : uncompress_image_file.sh
#: Date         : 07-Mar-2019
#: Author       : "Harsha Vardhan J" <vardhanharshaj@gmail.com>
#: Version      : 0.1 (Stable)
#: Description  : This script checks if the image file is compressed.
#                 If it is, the file is uncompressed and the extracted
#                 file(its absolute path) is returned as output.
#                
#: Options      : Requires a file as an argument.
#: Usage        : Call the script with a file as an argument
#                   ./uncompress_image_file.sh ../relative/file/path
#                   ./uncompress_image_file.sh /absolute/file/path
################


# Function that uncompresses image file if it's compressed
# Function input  : /path/to/compressed/file
# Function output : /absolute/path/to/image/file
#
function uncompress_image_file() {

	# Variable to store absolute path of compressed file
	local compressedFile

	# If number of arguments = 1
	if [[ $# -eq 1 ]] ; then
		# If the file is non-zero in size, and is readable by the \
		# user that the script is running as
		if [[ -s "$1" && -r "$1" ]] ; then
			# Call the function that checks if the input file is compressed,
			# and add the output to the 'compressedFile' variable
			compressedFile="$(uncompress_image_file__compression_check "$1")"

			# If the 'compressedFile' variable has been set and is not an empty string
			if [[ -v compressedFile && -n "${compressedFile}" ]] ; then

				# Calling function that picks the appropriate command to uncompress/extract
				# the compressed file based on the compression/archive type
				################# Uncompression Function #####################
				uncompress_image_file__uncompression_function "${compressedFile}" \
					|| print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 \
							-s "Error returned by the 'uncompression_function' module."
			
			fi
    # If the file doesn't exist, or is of size zero, or is unreadable by the user which
    # the script is running as
		else
      print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s "File \"$1\" either does not exist, is of zero-size, \
or is unreadable by the user \"${USER}\"."
		fi
	# If number of arguments is not equal to 1
	else
		print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s "Received $# arguments. Requires only 1."
	fi

}


# Function that checks if the image file is compressed
# Function input  : /path/to/file
# Function output : /absolute/path/to/file
function uncompress_image_file__compression_check() {
	# Compression file types to match
	# file types are generated by running
	# `file /path/to/file`
	local -a compressionTypeArray

	# Compression type of input file
	local compressionType


	# Obtained file types from the '/usr/share/file/magic.mgc'
	# file. It needs to be viewed using the 'strings' command.
	compressionTypeArray=("gzip compressed" "bzip2 compressed" \
							"GNU tar archive" "RAR archive data" \
							"Zip archive data" "7-zip archive data" \
							"XZ compressed data")
	
	# If number of arguments = 1
	if [[ $# -eq 1 ]] ; then
		# If the file is non-zero in size, and is readable by the
		# user that the script is running as
		if [[ -s "$1" && -r "$1" ]] ; then
			# Calling function to get the file's signature and setting the result to
			# the 'compressionType' variable
			compressionType="$(check_image_file__file_signature_check_method "$1")"

			# If the 'compressionType' variable has been set, meaning
			# if the 'signature_check_method' function returns a valid
			# output
			if [[ -v compressionType ]] ; then
				# For a list of all compression types listed in the
				# 'compressionTypeArray' array
				for TYPE in "${compressionTypeArray[@]}" ; do
					# If the 'compressionType' value matches any of the
					# values in the 'compressionTypeArray' array
					if [[ "${compressionType}" =~ "${TYPE}" ]] ; then
						# Print resolved symlinks or canonicalised file names \
						# as per 'readlink' manpage
						readlink -f "$1" \
							&& break
					fi
				done
			fi
		# If the file doesn't exist, or is of zero size, or is unreadable by the user
		# that the script is running as
		else
			print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s \
			"File \"$1\" either does not exist, is of zero-size, or is unreadable by the user \"${USER}\"."
		fi
	# If number of arguments is not equal to 1
	else
		print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s \
		"$# arguments have been provided. Requires only 1."
	fi

}


# Function that uncompresses the image file, if it is compressed
# Function input  : /path/to/compressed/file
# Function output : /path/to/uncompressed/file
function uncompress_image_file__uncompression_function() {

	# Local variable to store path to compressed file
	local compressedFile

	# Local variable to store the extension of the compressed file
	local fileExtension

	# Local associative array that stores the compression types \
	# as keys, and the decompression command as values
	local -A uncompressionCommands

	uncompressionCommands=(\
		["gz"]="tar -xvzf" \
		["zip"]="unzip" \
		["bz2"]="tar -xvjf" \
		["xz"]="xz -dk" \
	)


	# If number of arguments = 1, and if the argument is not an empty string
	if [[ $# -eq 1 && -n "$1" ]] ; then
		# Add the output of the 'compression_check' module to the 'compressedFile' variable
		compressedFile="$(uncompress_image_file__compression_check "$1" 2>/dev/null)"
	# If number of arguments != 1, and if the argument is an empty string
	else
		print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s \
		"Incorrect argument. Received \"$@\"."
	fi


	# If the 'compressedFile' variable has been set
	if [[ -v compressedFile ]] ; then
		# Obtain the file extension using substring removal
		# Take a look at bash hacker's wiki on substring removal \
		# for more info
		fileExtension="${compressedFile##*.}"

		# For a list of all indices(keys) of the array
		for EXTENSION in "${!uncompressionCommands[@]}" ; do
			if [[ "${fileExtension}" = "${EXTENSION}" ]] ; then
				# Uncompress the file using the command stored as \
				# the value of the corresponding key
				${uncompressionCommands["${EXTENSION}"]} "${compressedFile}" \
					|| print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s \
						"Could not extract the file \"#${compressedFile}\"."
			fi
		done
	# If the 'compressedFile' variable has not been set
	else
		print_err -f "${FUNCNAME}" -l "${LINENO}" -e 1 -s \
		"File did not match list of compressed file types."
	fi

}


# Main function that should be called
function uncompress_image_file__main() {
	# Local array for storing paths to file that are to \
	# be imported
	local -a importFiles
	importFiles=( "/Users/harshavardhanj/GitRepos/bash_scripts/usb_flash/general_functions.sh" )

	# Importing the 'general_functions.sh' script first
	source "/Users/harshavardhanj/GitRepos/bash_scripts/usb_flash/general_functions.sh"

	# Calling the 'import_files' function to help import scripts and prevent \
	# recursive importing
	import_files "${importFiles[@]}"
}


# Calling the main function
uncompress_image_file__main

# End of script